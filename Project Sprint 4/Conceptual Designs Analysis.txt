1. Ensure Completeness:
Our database is designed for a small offline game console rental company, which has only one database terminal (the store's PC), so the five entity sets, customers, consoles, inventory, rentals and transactions are already related to each other and are sufficient to cope with the demand. For example, rent calculations, order inquiries, and so on. The design of only two roles is also suitable for such a small company, easy to manage. Data integrity constraints are also implemented, including primary keys, foreign keys, unique constraints, and so on.

2. Maintain Correctness: The schema should use the concepts of the ER model correctly and accurately:
We have done Entity Relationship Diagram before the actual sql code, and added, deleted, modified, and checked according to the actual needs in the subsequent development. Each set (table) contains only one primary key, i.e. we have only one FD, primary_key->all_other_attributes, because this design ensures that the left side of each non-trivial function dependency is a superkey, so it conforms to BCNF, and redundancy is avoided as much as possible between the sets, so the design is very healthy and efficient.

3. Achieve Minimality: Each aspect of the schema should appear only once and be necessary for the requirements:
The schema we have designed is already very compact and can fulfill the basic functionality of a game console rental company. Each data item is stored only once to avoid data redundancy and ensure data consistency. For example, the consoles table stores information about consoles. Each console is uniquely identified by console_id, and other attributes (such as model, type, etc.) are stored only once and associated with a specific console_id. This helps keep the data consistent and makes querying and maintenance more efficient. Compliance with higher normalization forms, such as BCNF, eliminates the need for decomposition and further contributes to achieving minimality. Also, appropriate indexes are added to the tables to improve query performance.

4. Enhance Expressiveness: The schema should naturally represent the requirements and be easy to understand:
Our table structure is designed with clear and intuitive naming, making the attributes easy to understand and use. For example, the rentals table is specifically used to store rental information. The rental_id serves as a unique identifier for each rental record, while customer_id and console_id clearly indicate the rented customer and console, respectively. This design not only makes querying and managing rental information intuitive and efficient but also ensures that the schema naturally expresses the business needs. Additionally, we have incorporated appropriate constraints and default values to guarantee the integrity and consistency of the data, further enhancing the expressive power of the schema and intuitively displaying the relationship between data and business logic.

5. Improve Readability: The schema should be visually clear and aesthetically pleasing:
We designed the schema with a strong focus on readability. We used easy-to-understand naming conventions for tables, attributes, and relationships, which not only make them easy to recognize but also significantly improve readability. Furthermore, we took care to avoid adding any unnecessary elements to the schema, ensuring that it remains clutter-free and easy to navigate. This way, users (employees) can quickly grasp the data structure and efficiently manipulate it as needed.

6. Promote Self-Explanation: The schema should be self-explanatory with minimal need for external annotations:
Our schema has been designed with self-interpretation in mind. The table names, attribute names, and relationship names are all well-chosen and clearly represent their meanings, much like the readable interpretation mentioned earlier. For example, attributes such as payment_date and amount_paid clearly indicate the payment date and the amount paid, respectively. This design ensures that our schema is easy to understand without the need for additional explanation or annotation.

7. Ensure Extensibility: The schema should be easily adaptable to changing requirements:
Our schema is designed with high extensibility in mind. Each data item is stored only once, which not only optimizes storage but also ensures that as requirements change, the schema can be easily modified to accommodate new tables, attributes, or relationships without disrupting the existing structure. This design approach provides the flexibility needed to adapt to future changes.


Update: We added two new tables, VIP_customers inherited from the customers table, and weak entity set Membership_rewards. These two new tables cover two important application domain features, VIP customers and Membership rewards, ensuring the integrity of the database schema. At the same time, their design strictly follows the concepts of the ER model to ensure correctness. In terms of minimization, these two tables contain only the necessary attributes and associations to avoid redundancy. In addition, their clear and concise naming and structure enhance the expressive power of the database schema, making it more natural to represent application requirements and easy to understand. No additional documentations are required.